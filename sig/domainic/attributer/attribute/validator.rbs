module Domainic
  module Attributer
    class Attribute
      # A class responsible for validating attribute values.
      #
      # This class manages the validation of values assigned to an attribute. Validation
      # can be performed either by a Proc that accepts a single value argument and returns
      # a boolean, or by any object that responds to the `===` operator.
      #
      # @author {https://aaronmallen.me Aaron Allen}
      # @since 0.1.0
      class Validator
        type handler = proc | Proc | _ValidHandler

        type proc = ^(untyped value) -> bool

        interface _ValidHandler
          def !=: (untyped value) -> bool

          def ==: (untyped value) -> bool

          def ===: (untyped value) -> bool

          def inspect: () -> untyped

          def is_a?: (Class | Module) -> bool

          def respond_to?: (Symbol) -> bool
        end

        include BelongsToAttribute

        # Internal error class used to signal validation failures.
        # This allows us to differentiate between our intentional validation
        # failure signals and actual errors that occur during validation.
        #
        # @api private
        class ValidationFailure < Error
        end

        @handlers: Array[handler]

        # Initialize a new Validator instance.
        #
        # @param attribute [Attribute] the attribute this Validator belongs to
        # @param handlers [Array<Class, Module, Object, Proc>] the handlers to use for processing
        #
        # @return [Validator] the new instance of Validator
        def initialize: (Attribute attribute, Array[handler] | handler handlers) -> void

        # Validate a value using all configured validators.
        #
        # @param instance [Object] the instance on which to perform validation
        # @param value [Object] the value to validate
        #
        # @raise [ArgumentError] if the value fails validation
        # @raise [ValidationExecutionError] if errors occur during validation execution
        # @return [void]
        def call: (untyped instance, untyped value) -> void

        private

        # Handle a `nil` value.
        #
        # @raise [ArgumentError] if the attribute is not nilable
        # @return [true] if the attribute is nilable
        def handle_nil!: () -> bool

        # Handle an {Undefined} value.
        #
        # @raise [ArgumentError] if the attribute is required
        # @return [true] if the attribute is optional
        def handle_undefined!: () -> bool

        # Run all configured validations.
        #
        # Note on error handling strategy:
        # We use a custom ValidationFailure error class internally to distinguish between
        # two types of failures:
        # 1. Normal validation failures (when a validator returns false) are converted
        #    to ArgumentError to maintain the public API contract
        # 2. All other errors that occur during validation execution (including
        #    ArgumentError) are collected and wrapped in a ValidationExecutionError
        #
        # @param instance [Object] the instance on which to perform validation
        # @param value [Object] the value to validate
        #
        # @raise [ArgumentError] if the value fails validation
        # @raise [ValidationExecutionError] if errors occur during validation execution
        # @return [void]
        def run_validations!: (untyped instance, untyped value) -> void

        # Validate that a validation handler is valid.
        #
        # @param handler [Object] the handler to validate
        #
        # @raise [TypeError] if the handler is not valid
        # @return [void]
        def validate_handler!: (handler handler) -> void

        # Validate a value using a single handler.
        #
        # @param handler [Object] the handler to use for validation
        # @param instance [Object] the instance on which to perform validation
        # @param value [Object] the value to validate
        def validate_value!: (handler handler, untyped instance, untyped value) -> bool
      end
    end
  end
end
